# 队列

## 为什么会出现消息队列？

1. 异步：常见的B/S架构下，客户端向服务器发送请求，但是服务器处理这个消息需要花费的时间很长的时间，如果客户端一直等待服务器处理完消息，会造成客户端的系统资源浪费；而使用消息队列后，服务器直接将消息推送到消息队列中，由专门的处理消息程序处理消息，这样客户端就不必花费大量时间等待服务器的响应了；
2. 解耦：传统的软件开发模式，模块之间的调用是直接调用，这样的系统很不利于系统的扩展，同时，模块之间的相互调用，数据之间的共享问题也很大，每个模块都要时时刻刻考虑其他模块会不会挂了；使用消息队列以后，模块之间不直接调用，而是通过数据，且当某个模块挂了以后，数据仍旧会保存在消息队列中。最典型的就是**生产者-消费者**模式，本案例使用的就是该模式；
3. 削峰填谷：某一时刻，系统的并发请求暴增，远远超过了系统的最大处理能力后，如果不做任何处理，系统会崩溃；使用消息队列以后，服务器把请求推送到消息队列中，由专门的处理消息程序以合理的速度消费消息，降低服务器的压力。

## 使用队列带来的问题？



###系统可用性降低

 系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以[点击这里查看]()。

###系统复杂度提高

 硬生生加个 MQ 进来，你怎么[保证消息没有重复消费]？怎么[处理消息丢失的情况]？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。

1.重复消费

对服务做幂等

后端幂等性方案：

* 数据库使用唯一索引

* token机制+redis(还得使用锁保证并发问题)

客户端每次在调用接口的时候,需要在请求头中，传递令牌参数，每次令牌只能用一次。

一旦使用之后，就会被删除，这样可以有效防止重复提交。

* 状态机幂等，一个业务场景交易所发起一笔提币请求有0:已提交 1:审核中 2:处理中  3:已成功4:失败 5: 取消提现',系统设计时，值支持状态的单向改变 ，where条件中 有个status = 原来的状态
* 通过乐观锁实现
* 全局唯一编号

2.消息丢失

消息补偿机制

在消息发送是将消息发送日志记录到db中，定时想db轮序发送消息的状态，查明没有消费成功的消息，进行重发。

3.顺序消费

一个队列对应一个消费者

###一致性问题

 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。

用到分布式事务

